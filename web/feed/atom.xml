<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>kpacha</title>
    <subtitle>Hacking around</subtitle>
    <link href="http://kpacha.github.io/feed/index.atom" rel="self" />
    <link href="http://kpacha.github.io/" />
        <id>http://kpacha.github.io/</id>
            <updated>2014-02-14T00:00:00+01:00</updated>
            <entry>
        <title>Building a simple static blog with carew</title>
                <id>http://kpacha.github.io/2014/01/12/building-a-simple-static-blog-with-carew.html</id>
                <updated>2014-01-12T00:00:00+01:00</updated>
        <author>
            <name>kpacha</name>
            <email>kpacha666@gmail.com</email>
        </author>
        <link rel="alternate" type="text/html" href="http://kpacha.github.io/2014/01/12/building-a-simple-static-blog-with-carew.html"/>
        <content type="html" xml:lang="en"><![CDATA[<p>I think the best topic for a first post must be 'how did I build this?', so here we go!</p>

<p>First of all, as I want my blog be served at github pages, I create a new repo name kpacha.github.io. I know the <a href="http://carew.github.io/cookbook/hosting.html">cookbook</a> recomends an easier way, but I don't want the carew installation on my <code>master</code> branch so, my repo has two branches:</p>

<ul><li>The <code>master</code> branch stores the last static website builded as it's intended to serve the web contents for github pages</li>
<li>The <code>editor</code> branch stores the carew project and all the markdown pages</li>
</ul><p>So the workflow I'm following here is quite simple:</p>

<ul><li>checkout the <code>editor</code> branch</li>
<li>create new post</li>
<li>re-build website</li>
<li>commit changes</li>
<li>merge the new website to <code>master</code></li>
<li>commit changes</li>
<li>push both branches</li>
</ul><h2 id="initial-setup">Initial setup<a href="#initial-setup" class="anchor">#</a></h2>

<p>Create a new github repo named <code>&lt;YOUR-GITHUB-USER&gt;.github.io</code> and clone it somewhere in your system</p>

<pre><code>$ git clone https://github.com/&lt;YOUR-GITHUB-USER&gt;/&lt;YOUR-GITHUB-USER&gt;.github.io.git
$ cd &lt;YOUR-GITHUB-USER&gt;.github.io
</code></pre>

<h2 id="editor-branch">Editor branch<a href="#editor-branch" class="anchor">#</a></h2>

<p>Create your <code>editor</code> branch just typing</p>

<pre><code>$ git checkout -b editor
</code></pre>

<h3 id="carew-installation">Carew Installation<a href="#carew-installation" class="anchor">#</a></h3>

<p>The best way to start with carew is to use the carew boilerplate: You will need composer.</p>

<pre><code>$ php composer.phar create-project carew/boilerplate . -s dev
$ bin/carew build
</code></pre>

<p>That's all, you can browse the <code>web/</code> directory.</p>

<p>Now you must edit the <code>confi.yml</code> and the <code>posts/</code> and <code>pages/</code> folder contents.</p>

<h3 id="git-integration">Git integration<a href="#git-integration" class="anchor">#</a></h3>

<p>Once your <code>editor</code> branch has a carew project working, it's time to integrate it in your workflow. It could be done just by adding two more files to the <code>editor</code> branch: <code>.gitignore</code> and <code>install</code>.</p>

<p><code>.gitignore</code> will prevent you from adding the <code>bin/</code> and <code>vendor/</code> folders</p>

<pre><code>/vendor/
/bin/
</code></pre>

<p>Also, <code>install</code> will be useful when you want to install your <code>editor</code> environment after a <code>git clone</code></p>

<pre><code>#!/bin/bash
composer install -o
bin/carew build
</code></pre>

<p>Remeber to add execution permisions</p>

<pre><code>chmod +x install
</code></pre>

<p>Now you can add the root folder into git.</p>

<p>In future checkouts from scratch, you will need to run the <code>install</code> script before be ready to work!</p>

<pre><code>$ git clone https://github.com/kpacha/kpacha.github.io.git
$ git checkout editor
$ ./install
</code></pre>

<h2 id="master-branch">Master branch<a href="#master-branch" class="anchor">#</a></h2>

<p>Checkout your <code>master</code> branch</p>

<pre><code>$ git checkout master
</code></pre>

<p>And add the <code>.gitignore</code> file from the <code>editor</code> branch</p>

<pre><code>$ git checkout editor -- .gitignore
</code></pre>

<p>Create a file called <code>update.sh</code></p>

<pre><code>#!/bin/bash
git checkout editor -- web
cp -rp web/* .
rm -rf web
git reset HEAD web
git status
</code></pre>

<p>After adding the execution permissions to <code>update.sh</code>, add them to git</p>

<pre><code>$ chmod +x update.sh
$ git add .gitignore update.sh
$ git commit -m "set up the master branch"
</code></pre>

<p>Now, every time you want to push your generated statics you must run the <code>update.sh</code> script, add the untracked files listed, commit them and push the branch to github</p>

<h2 id="posting">Posting<a href="#posting" class="anchor">#</a></h2>

<p>From the <code>editor</code> branch, create your post entry</p>

<pre><code>$ bin/carew generate:post "New post title"
</code></pre>

<p>Edit your entry and rebuild your web</p>

<pre><code>$ bin/carew build
</code></pre>

<p>Now it's time to commit your changes into your <code>editor</code> branch and update your <code>master</code> one. Just type</p>

<pre><code>$ git add .
$ git commit -m "adding the 'New post title'"
$ git checkout master
$ ./update.sh
$ git add .
$ git commit -m "publishing the 'New post title'"
$ git push origin editor
$ git push origin master
</code></pre>

<p>And you're done!</p>

<h2 id="extra-tip">Extra tip<a href="#extra-tip" class="anchor">#</a></h2>

<p>Put the code for posting in a script for faster publishing. Let's call it <code>publish</code></p>

<pre><code>#!/bin/bash
git add .
git commit -m "adding the '$1'"
git checkout master
./update.sh
git add .
git commit -m "publishing the '$1'"
git push origin editor
git push origin master
</code></pre>

<p>Do not forget to set the execution permisions</p>

<pre><code>$ chmod +x publish
</code></pre>

<p>And, after a succesful build, just run</p>

<pre><code>$ ./publish "New post title"
</code></pre>]]></content>
    </entry>
        <entry>
        <title>Improving the css/js compression process</title>
                <id>http://kpacha.github.io/2014/02/14/improving-the-css-js-compression-process.html</id>
                <updated>2014-02-14T00:00:00+01:00</updated>
        <author>
            <name>kpacha</name>
            <email>kpacha666@gmail.com</email>
        </author>
        <link rel="alternate" type="text/html" href="http://kpacha.github.io/2014/02/14/improving-the-css-js-compression-process.html"/>
        <content type="html" xml:lang="en"><![CDATA[<p>Everybody in the web business knows that deploying uncompressed css/js files is a bad idea. It is a waste of time and money since storage and bandwith usually are not free resources (this web is a clear exception, so here I do not care too much). And the website will take more time to get fully rendered. So people use tools like <a href="http://yui.github.io/yuicompressor/">yui-compressor</a> in order to minify their css and javascript files. But adding those compressed files to the SCM tool does not feel right because there is no way to know if the compressed files are up to date with the uncompressed version. The solution is compress those files just before deploying a new version.</p>

<p>This aproach is fine if you are deploying a pre-builded package to your servers. But, what if you are just checking out the code from your SCM? In this scenario, you will need to install your compressing tool (with all its requirements) in every server and trigger the compression process after the checkout. Why would you spend so much time doing the same operation again and again? Are your files different from one host to another or are they almost the same? How often do you deploy? Just take the DRY pattern to the next abstraction level and delegate that process to a dedicated service!</p>

<p>Here <a href="http://kpacha.github.io/yuicompressor-server/">yuicompressor-server</a> comes up. Since yui-compressor is the most adopted compression tool and since it is a FOSS java project, it sounds good to me to bundle the jar with a lightweight http service and centralize the locally installed compression tool in a dedicated server. This solution gives some extra benefits:</p>

<ul><li><em>Less software requirements on the app servers</em>. If they are running a pure php-based app, why should they require a jdk?</li>
<li><em>More resource reutilization</em> since you are instantiating less compressors... And there is a single jvm in a dedicated and customized server!</li>
<li><em>Fault tolerance</em>. Just launch a set of yuicompressor-server hosts and add them to your deployment process. This HA configuration removes any SPOF (single point of failure) and improves the service continuation because the probability of unsuccesful deployments due errors (related to the compression processes and results) is almost zero.</li>
<li><em>Cachable responses for free</em>. It is a http service so you can use the cache headers and any network intermediary will cache your responses. Also, you can place a front-end cache (dedicated or embedded) and reduce the response time and server load. <a href="https://www.varnish-cache.org/">Varnish</a> and <a href="http://ehcache.org/">Ehcache</a> are your friends... but are you really generating so much requests?</li>
</ul><p>Finally, you will end with a faster deployment process and an easier infraestructure.</p>

<p>For the http service, I choose an embedded <a href="http://www.eclipse.org/jetty/">jetty</a>. I discovered it some time ago playing with the <a href="http://www.ninjaframework.org/">ninja framework</a> and I love it. It gets a well tested, very stable and pretty fast http server. And it is as easy to use that it requires just few lines of code to get it running!</p>

<p>The yuicompressor-server is not the best solution but it is the next baby-step in the continuous improvement process. It is the small hop you make to get things running better without any big, risky change. Some day in the future, your CI server will handle the css/js compression task before packaging a release and deploy it. Then, after celebrating your new achivement in the long road to the perfect processes and the leanest environment, you will be able to shutdown your compressor server and forget it. Until that happy day, why should you be doing nothing to improve your daily work?</p>

<p>Read more about <a href="http://kpacha.github.io/yuicompressor-server/">yuicompressor-server</a> or inspect the <a href="http://github.com/kpacha/yuicompressor-server/">code</a></p>]]></content>
    </entry>
    </feed>
